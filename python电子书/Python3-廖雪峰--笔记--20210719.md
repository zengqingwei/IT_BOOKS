



<center>Python3-廖雪峰学习笔记</center>







#  python正则



表 1-1 常见正则表达式符号和特殊字符
表 示 法 描 述 正则表达式示例
符号
literal 匹配文本字符串的字面值 literal foo
re1|re2 匹配正则表达式 re1 或者 re2 foo|bar
. 匹配任何字符（除了\n 之外） b.b
^ 匹配字符串起始部分 ^Dear
$ 匹配字符串终止部分 /bin/*sh$

* 匹配 0 次或者多次前面出现的正则表达式 [A-Za-z0-9]*
+ 匹配 1 次或者多次前面出现的正则表达式 [a-z]+\.com
? 匹配 0 次或者 1 次前面出现的正则表达式 goo?
{N} 匹配 N 次前面出现的正则表达式 [0-9]{3}
{M,N} 匹配 M～N 次前面出现的正则表达式 [0-9]{5,9}
[…] 匹配来自字符集的任意单一字符 [aeiou]
[..x−y..] 匹配 x ～ y 范围中的任意单一字符 [0-9], [A-Za-z]
[^…] 不匹配此字符集中出现的任何一个字符，包括某一范围的字符（如果在此字符集中出现） [^aeiou], [^A-Za-z0-9]
(*|+|?|{})? 用于匹配上面频繁出现/重复出现符号的非贪婪版本（*、+、?、{}） .*?[a-z]
(…) 匹配封闭的正则表达式，然后另存为子组 ([0-9]{3})?,f(oo|u)bar

![image-20210719100725860](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719100726.png)





![image-20210719100835020](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719100835.png)



匹配多个模式。



![image-20210719101241753](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719101241.png)





从字符串起始或者结尾或者单词边界匹配
还有些符号和相关的特殊字符用于在字符串的起始和结尾部分指定用于搜索的模式。如
果要匹配字符串的开始位置，就必须使用脱字符（^）或者特殊字符\A（反斜线和大写字母 A）。
后者主要用于那些没有脱字符的键盘（例如，某些国际键盘）。同样，美元符号（$）或者\Z
将用于匹配字符串的末尾位置。
使用这些符号的模式与本章描述的其他大多数模式是不同的，因为这些模式指定了位置
或方位。之前的“核心提示”记录了匹配（试图在字符串的开始位置进行匹配）和搜索（试
图从字符串的任何位置开始匹配）之间的差别。正因如此，下面是一些表示“边界绑定”的
正则表达式搜索模式的示例。



![image-20210719101525877](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719101525.png)



再次说明，如果想要逐字匹配这些字符中的任何一个（或者全部），就必须使用反斜线进
行转义。例如，如果你想要匹配任何以美元符号结尾的字符串，一个可行的正则表达式方案就是使用模式.*\$$。
特殊字符\b 和\B 可以用来匹配字符边界。而两者的区别在于\b 将用于匹配一个单词的边界，这意味着如果一个模式必须位于单词的起始部分，就不管该单词前面（单词位于字符串中间）是否有任何字符（单词位于行首）。同样，\B 将匹配出现在一个单词中间的模式（即，
不是单词边界）。





正则表达式模式	匹配的字符串
the 						任何包含 the 的字符串
\bthe 					任何以 the 开始的字符串
\bthe\b 				 仅仅匹配单词 the
\Bthe 					任何包含但并不以 the 作为起始的字符串







![](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719101849.png)

```
正则表达式模式 匹配的字符串
b[aeiu]t bat、bet、bit、but
[cr][23][dp][o2]
一个包含四个字符的字符串，第一个字符是“c”或“r”，然后是“2”或“3”，后面
是“d”或“p”，最后要么是“o”要么是“2”。例如，c2do、r3p2、r2d2、c3po 等
```



![image-20210719102010280](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719102010.png)



使用闭包操作符实现存在性和频数匹配

```
本节介绍最常用的正则表达式符号，即特殊符号*、+和？，所有这些都可以用于匹配一个、多个或者没有出现的字符串模式。星号或者星号操作符（*）
将匹配其左边的正则表达式出现零次或者多次的情况（在计算机编程语言和编译原理中，该操作称为 Kleene 闭包）。加
号（+）操作符将匹配一次或者多次出现的正则表达式（也叫做正闭包操作符），问号（？）操作符将匹配零次或者一次出现的正则表达式。
还有大括号操作符（{}），里面或者是单个值或者是一对由逗号分隔的值。这将最终精确地匹配前面的正则表达式 N 次（如果是{N}）
或者一定范围的次数；例如，{M ， N}将匹配 M～N 次出现。这些符号能够由反斜线符号转义；\*匹配星号，等等。
注意，在之前的表格中曾经多次使用问号（重载），这意味着要么匹配 0 次，要么匹配 1次，或者其他含义：如果问号紧跟在任何使用闭合操作符
的匹配后面，它将直接要求正则表达式引擎匹配尽可能少的次数。
“尽可能少的次数”是什么意思？当模式匹配使用分组操作符时，正则表达式引擎将试图
“吸收”匹配该模式的尽可能多的字符。这通常被叫做贪婪匹配。问号要求正则表达式引擎去
“偷懒”，如果可能，就在当前的正则表达式中尽可能少地匹配字符，留下尽可能多的字符给
后面的模式（如果存在）。本章末尾将用一个典型的示例来说明非贪婪匹配是很有必要的。现
在继续查看闭包操作符。
```



![image-20210719102141881](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719102141.png)







表示字符集的特殊字符



```
我们还提到有一些特殊字符能够表示字符集。与使用“0-9”这个范围表示十进制数相比，
可以简单地使用 d 表示匹配任何十进制数字。另一个特殊字符（\w）能够用于表示全部字母
数字的字符集，相当于[A-Za-z0-9_]的缩写形式，\s 可以用来表示空格字符。这些特殊字符的
大写版本表示不匹配；例如，\D 表示任何非十进制数（与[^0-9]相同），等等。
使用这些缩写，可以表示如下一些更复杂的示例
```

![image-20210719102714634](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719102714.png)





```
使用圆括号指定分组
现在，我们已经可以实现匹配某个字符串以及丢弃不匹配的字符串，但有些时候，我们
可能会对之前匹配成功的数据更感兴趣。我们不仅想要知道整个字符串是否匹配我们的标准，
而且想要知道能否提取任何已经成功匹配的特定字符串或者子字符串。答案是可以，要实现
这个目标，只要用一对圆括号包裹任何正则表达式。
当使用正则表达式时，一对圆括号可以实现以下任意一个（或者两个）功能：
• 对正则表达式进行分组；
• 匹配子组。
关于为何想要对正则表达式进行分组的一个很好的示例是：当有两个不同的正则表达式
而且想用它们来比较同一个字符串时。另一个原因是对正则表达式进行分组可以在整个正则
表达式中使用重复操作符（而不是一个单独的字符或者字符集）。
使用圆括号进行分组的一个副作用就是，匹配模式的子字符串可以保存起来供后续使用。
这些子组能够被同一次的匹配或者搜索重复调用，或者提取出来用于后续处理。1.3.9 节的结
尾将给出一些提取子组的示例。
为什么匹配子组这么重要呢？主要原因是在很多时候除了进行匹配操作以外，我们还想
要提取所匹配的模式。例如，如果决定匹配模式\w+-\d+，但是想要分别保存第一部分的字母
和第二部分的数字，该如何实现？我们可能想要这样做的原因是，对于任何成功的匹配，我
们可能想要看到这些匹配正则表达式模式的字符串究竟是什么。
如果为两个子模式都加上圆括号，例如(\w+)-(\d+)，然后就能够分别访问每一个匹配
子组。我们更倾向于使用子组，这是因为择一匹配通过编写代码来判断是否匹配，然后
第 1 章 正则表达式 11
执行另一个单独的程序（该程序也需要另行创建）来解析整个匹配仅仅用于提取两个部
分。为什么不让 Python 自己实现呢？这是 re 模块支持的一个特性，所以为什么非要重蹈
覆辙呢？
```

![image-20210719103315803](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719103315.png)



扩展表示法
我们还没介绍过的正则表达式的最后一个方面是扩展表示法，它们是以问号开始（?…）。
我们不会为此花费太多时间，因为它们通常用于在判断匹配之前提供标记，实现一个前视（或
者后视）匹配，或者条件检查。尽管圆括号使用这些符号，但是只有（?P<name>）表述一个
分组匹配。所有其他的都没有创建一个分组。然而，你仍然需要知道它们是什么，因为它们
可能最适合用于你所需要完成的任务。



![image-20210719103436865](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719103436.png)





正则表达式和 Python 语言
在了解了关于正则表达式的全部知识后，开始查看 Python 当前如何通过使用 re 模块来
支持正则表达式，re 模块在古老的 Python 1.5 版中引入，用于替换那些已过时的 regex 模块
和 regsub 模块——这两个模块在 Python 2.5 版中移除，而且此后导入这两个模块中的任意一
个都会触发 ImportError 异常。
re 模块支持更强大而且更通用的 Perl 风格（Perl 5 风格）的正则表达式，该模块允许多
个线程共享同一个已编译的正则表达式对象，也支持命名子组。





# python解释器



Python 的解释器很多，但使用最广泛的还是 CPython。如果要和 Java
或.Net 平台交互，最好的办法不是用 Jython 或 IronPython，而是通过网
络调用来交互，确保各程序之间的独立性。



Python 的交互模式和直接运行 .py 文件有什么区别呢？
直接输入 python 进入交互模式，相当于启动了 Python 解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。



直接运行 .py 文件相当于启动了 Python 解释器，然后一次性把 .py 文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。







![image-20210719143230792](https://cdn.jsdelivr.net/gh/zengqingwei/img/20210719143230.png)







所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成 CPU 能够执行的
机器码，然后执行。Python 也不例外。



Python 的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：

```python
# print absolute value of an integer:
a = 100
if a >= 0:
	print(a)
else:
	print(-a)
```

以 # 开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，

当语句以冒号 : 结尾时，缩进的语句视为代码块。

缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是 Tab。按照约定俗成的管理，应该始终坚持使用 4 个空格的缩进。

**如果tab和空格混用于缩进那么就会报语法错误** ，因为python解释器对于空格和tab还是有区分的。

请务必注意，Python 程序是**大小写敏感**的，如果写错了大小写，程序会报错。

在文本编辑器中，需要设置把 Tab 自动转换为 4 个空格，确保不混用Tab 和空格



# 数据类型和变量



计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需
要定义不同的数据类型。在 Python 中，能够直接处理的数据类型有以下几种：



## 整数



ython 可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如： 1 ， 100 ， -8080 ， 0 ，等等

## 浮点数

浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的。但是对于很大或很小的浮点数，就必须用科学计数法表示，把 10 用 e 替代，1.23x10 9 就是 1.23e9 ，或者 12.3e8 ，0.000012 可以写成 1.2e-5 ，等等

整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。

## 字符串

是以单引号 ' 或双引号 " 括起来的任意文本，比如 'abc' ， "xyz" 等等。请注意， '' 或 "" 本身只是一种表示方式，不是字符串的一部分，因
此，字符串 'abc' 只有 a ， b ， c 这 3 个字符，字符串内包含特殊字符需要使用转义字符。例如：

```python
'I\'m \"OK\"!'  表示的字符串内容是：I'm "OK"!

# 转义字符 \ 可以转义很多字符，比如 \n 表示换行， \t 表示制表符，字符 \本身也要转义，所以 \\ 表示的字符就是 \

#为了简化，Python 还允许用 r'' 表示 '' 内部的字符串默认不转义，可以自己试试：
In [4]:  print('\\\t\\')
\	\
In [5]: print(r'\\\t\\')
\\\t\\
In [6]:#换行，用 \n 写在一行里不好阅读，为了简化，Python 允许用 '''...''' 的格式表示多行内容，可以自己试试：
In [6]:  print('''line1
   ...: ... line2     #...:前面的这个是表示缩进，后面的三个点...表示多行注释。
   ...: ... line3''')
line1
line2
line3

```

## 布尔值

布尔值和布尔代数的表示完全一致，一个布尔值只有 True 、 False 两种值，要么是 True ，要么是 False ，在 Python 中，可以直接用 True 、 False表示布尔值（请注意大小写），也可以通过布尔运算计算出来,布尔值可以用 and 、 or 和 not 运算。and 运算是与运算，只有所有都为 True ， and 运算结果才是 True ：

```python
>>> True
True
>>> False
False
>>> 3 > 2
True
>>> 3 > 5
False
In [15]: True or True  #or或者，and并且
Out[15]: True
In [16]: True or False
Out[16]: True
In [17]: True and False
Out[17]: False
In [18]: False or False  #False and False还是 False
Out[18]: False
In [19]: False and False
Out[19]: False
In [20]: not True #not 取反
Out[20]: False
In [21]: not False
Out[21]: True
In [22]: not 1>2
Out[22]: True
    
# 布尔值经常用在条件判断中，比如：
if age >= 18:
    print('adult')
else:
	print "no"
    

```

## 空值



空值是 Python 里一个特殊的值，用 None 表示。 None 不能理解为 0 ，因为 0 是有意义的，而 None 是一个特殊的空值。





## 列表



列表是可变的，使用中括号表示，里面的值可以是重复的。

序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。

Python有6个序列的内置类型，但最常见的是列表和元组。

序列都可以进行的操作包括索引，切片，加，乘，检查成员。

此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。

列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。

列表的数据项不需要具有相同的类型，也就是可以重复。

创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：



当索引超出了范围时，Python 会报一个 IndexError 错误，所以，要确保
索引不要越界，记得最后一个元素的索引是 len(classmates) - 1 。 ，引用就是list1[-1] 变量后中括号中间，没有点。-1表示最后一个元素。

```python
list = ['red', 'green', 'blue', 'yellow', 'white', 'black']

In []: for i in list: #循环全部打印处理
    ...:     print i
    ...: 
red
green
blue
yellow
white
black


#访问列表中的值
#打印元素通过列表小标方式，元素排位是从0开始，
下标是-1表示最后一个，负号表示从右开始数的下标。

In []: print( list[0] )
red
In [34]: for i in list
  File "<ipython-input-34-c39000217b33>", line 1 #超过下标会报错。
    for i in list
                 ^
SyntaxError: invalid syntax

#更新列表
list1=[]
list1.append("aa")
list1.append("bb")
In [41]: print list1
['aa', 'bb']
#要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：
list[1]='123'

#也可以把元素插入到指定的位置，比如索引号为 1 的位置：
>>> classmates.insert(1, 'Jack')

#删除列表元素
In [42]: del list1[1]
In [43]: print list1
['aa']

#pop弹出最后一个元素
In [45]: list1=["aa","bb","cc","dd","ee","ff"]
#要删除指定位置的元素，用 pop(i) 方法，其中 i 是索引位置。
list.pop() #默认最后一个。
list.pop(2)

In [46]: print list1
['aa', 'bb', 'cc', 'dd', 'ee', 'ff']
In [48]: list1.pop()  #删除最后一个元素
Out[48]: 'ff'
In [49]: print list1
['aa', 'bb', 'cc', 'dd', 'ee']

#列表截取
print list01[0]
print list01[-1]
print list01[0:3]

# 元素是否存在于列表中
print 'john' in list02  # True

# 将元组转换为列表

aTuple = (1,2,3,4)
list03 = list(aTuple)
print list03

#列表嵌套，列表里面存放列表。这样取出第一层是个列表之后如果要取出最里边一层数据需要再次循环或者[1]列表下标调用
In [50]: a = ['a', 'b', 'c']
In [51]: n = [1, 2, 3]
In [52]: x = [a, n]
In [53]: x
Out[53]: [['a', 'b', 'c'], [1, 2, 3]]
In [54]: x[0]
Out[54]: ['a', 'b', 'c']
In [55]: x[0][1] #说明 x[0]是列表a，想要在次取出a列表的值再加一个下标[1]进行取值
Out[55]: 'b'
In [59]: for i in x:
    ...:     print i
    ...:     for y in i :
    ...:         print y
    ...: 
['a', 'b', 'c']
a
b
c
[1, 2, 3]
1
2
3


```

列表内置函数： 

| 序号 | 函数                                                         |
| :--- | :----------------------------------------------------------- |
| 1    | [cmp(list1, list2)](https://www.runoob.com/python/att-list-cmp.html) 比较两个列表的元素 |
| 2    | [len(list)](https://www.runoob.com/python/att-list-len.html) 列表元素个数 |
| 3    | [max(list)](https://www.runoob.com/python/att-list-max.html) 返回列表元素最大值 |
| 4    | [min(list)](https://www.runoob.com/python/att-list-min.html) 返回列表元素最小值 |
| 5    | [list(seq)](https://www.runoob.com/python/att-list-list.html) 将元组转换为列表 |

列表内置方法： 也可以使用dir(liet) 方法查看所有内容方法

| 序号 | 方法                                                         |
| :--- | :----------------------------------------------------------- |
| 1    | [list.append(obj)](https://www.runoob.com/python/att-list-append.html) 在列表末尾添加新的对象 |
| 2    | [list.count(obj)](https://www.runoob.com/python/att-list-count.html) 统计某个元素在列表中出现的次数 |
| 3    | [list.extend(seq)](https://www.runoob.com/python/att-list-extend.html) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |
| 4    | [list.index(obj)](https://www.runoob.com/python/att-list-index.html) 从列表中找出某个值第一个匹配项的索引位置 |
| 5    | [list.insert(index, obj)](https://www.runoob.com/python/att-list-insert.html) 将对象插入列表 |
| 6    | [list.pop([index=-1\])](https://www.runoob.com/python/att-list-pop.html) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |
| 7    | [list.remove(obj)](https://www.runoob.com/python/att-list-remove.html) 移除列表中某个值的第一个匹配项 |
| 8    | [list.reverse()](https://www.runoob.com/python/att-list-reverse.html) 反向列表中元素 |
| 9    | [list.sort(cmp=None, key=None, reverse=False)](https://www.runoob.com/python/att-list-sort.html) 对原列表进行排序 |



## 元组

另一种有序列表叫元组：tuple。tuple 和 list 非常类似，但是 tuple 一旦初始化就不能修改，比如同样是列出同学的名字：

元组使用小括号，列表使用方括号。元组一般存放一些不能修改的数据和变量，保护数据不被修改。

**重要** 元组的陷阱：当你定义一个 tuple 时，在定义的时候，tuple 的元素就必须被确定下来，因为后面他不能被修改。



元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。

这个 tuple 不能变了，它也没有 append()，insert()这样的方法。其他获取元素的方法和 list 是一样的，你可以正常地使用
classmates[0] ， classmates[-1] ，但不能赋值成另外的元素。

```python
tup1 = ('physics', 'chemistry', 1997, 2000)
tup2 = (1, 2, 3, 4, 5 )
tup3 = "a", "b", "c", "d"
#创建空元组
tup1 = ()
#元组中只包含一个元素时，需要在元素后面添加逗号
tup1 = (50,)
#元组与字符串类似，下标索引从0开始，可以进行截取，组合等。
#访问元组里面的元素
In [86]: tup1[0]
Out[86]: 50
In [87]: tup2 = (1, 2, 3, 4, 5, 6, 7 )
In [88]: print "tup2[1:5]: ", tup2[1:5] #打印元组1到5的元素。
tup2[1:5]:  (2, 3, 4, 5)
    
#修改元组
#元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:
tup1 = (12, 34.56)
tup2 = ('abc', 'xyz')
# 以下修改元组元素操作是非法的。
# tup1[0] = 100
 
# 创建一个新的元组,也就是通过元组给变量赋值，这样使用新的值相当于对元组数据进行I修改。本质原来的元素数据是无法修改的。
tup3 = tup1 + tup2
print tup3


#删除元组
#元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:
tup = ('physics', 'chemistry', 1997, 2000)
print tup
del tup #整个删除元组
print "After deleting tup : "
print tup  #删除后再次调用变量会报错。


```



## 集合



集合是和字段比较类似，或者说是特殊的字段，他只有key没有value值。由于 key 不能重复，所以，在 set 中，没有重复的 key。

集合不能有重复值。Python 中的集合（set）类型同数学中的集合概念一致，即包含0或多个数据项的无序组合。

> - 集合中的元素不可重复。
> - 集合是无序组合，没有索引和位置的概念。
> - set() 函数用于集合的生成，返回结果是一个无重复且排序任意的集合。
> - 集合通常用于表示成员间的关系、元素去重等。

```python
#集合赋值，重复元素在 set 中自动被过滤：
set_obj = set() #创建一个空集合

In [11]: s = set([1, 2, 3]) #集合赋值也是括号，但是多了个set关键字说明他是集合

In [12]: s
Out[12]: {1, 2, 3}
    
In [14]: type(s)
Out[14]: set

In [15]: t=(1,2)  #括号赋值没有set关键字，默认是元组。

In [16]: type(t)
Out[16]: tuple
    
>>> s = set([1, 1, 2, 2, 3, 3])
>>> s
{1, 2, 3}

#通过 add(key) 方法可以添加元素到 set 中，可以重复添加，但不会有效
#添加元素到集合中
set_obj.add(element)

set_obj = set()
set_obj.add("aa")

In [21]: set_obj
Out[21]: {'aa'}
    
#通过 remove(key) 方法可以删除元素：

#集合也可以进行运算

>>> s1 = set([1, 2, 3])
>>> s2 = set([2, 3, 4])
>>> s1 & s2
{2, 3}
>>> s1 | s2
{1, 2, 3, 4}

set_obj.clear()  #清空集合


```

对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证
了不可变对象本身永远是不可变的。











## 字典

dict是键值对，通过键来查找值。使用场景：举个例子，假设要根据同学的名字查找对应的成绩，如果用 list 实现，
需要两个 list：给定一个名字，要查找对应的成绩，就先要在 names 中找到对应的位置，
再从 scores 取出对应的成绩，list 越长，耗时越长。

如果用 dict 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用 Python 写一个dict 如下：

```python
>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
>>> d['Michael']
95
```

为什么 dict 查找速度这么快？因为 dict 的实现原理和查字典是一样的。可以理解为，key就是字段的索引字段，他每次都是通过查key得到的值，这样就快了。

数据放入 dict 的方法，除了初始化时指定外，还可以通过 key 放入：

```python
>>> d['Adam'] = 67
>>> d['Adam']
67

In [6]: d
Out[6]: {'Michael': 95, 'Bob': 75, 'Tracy': 85}
In [7]:   d['Bob']=11

In [8]: d
Out[8]: {'Michael': 95, 'Bob': 11, 'Tracy': 85}
    
# 一个 key 只能对应一个 value,多次对一个 key 放入 value，后面的值会把前面的值冲掉

```

如果 key 不存在，dict 就会报错：

要避免 key 不存在的错误，有两种办法，

一是通过 in 判断 key 是否存在

二是通过 dict 提供的 get 方法，如果 key 不存在，可以返回 None，或者自己指定的 value：

```python
## in 方法
In [11]: 'Bob' in d
Out[11]: True
## get方法    
In [2]: d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}

In [3]: 'Bob' in d
Out[3]: True

In [4]: d.get('Bob')
Out[4]: 75

In [5]: d.get('aa')
#    没有不返回
In [6]: d.get('aa','bb')  
Out[6]: 'bb'  #如果字典d里面没有aa这个键，就返回bb字符串
    
#要删除一个 key，用 pop(key) 方法，对应的 value 也会从 dict 中删除
In [7]: d.pop('Bob')
Out[7]: 75

In [8]: d
Out[8]: {'Michael': 95, 'Tracy': 85}
    
 
```

请务必注意，dict 内部**存放顺序和 key 顺序**是没有关系的。
和 list 比较，dict 有以下几个特点：

1. 查找和插入的速度极快，不会随着 key 的增加而增加；
2. 需要占用大量的内存，内存浪费多。

而 list 相反：

1. 查找和插入的时间随着元素的增加而增加；
2. 占用空间小，浪费内存很少。

所以，dict 是用空间来换取时间的一种方法。



正确使用 dict 非常重要，需要牢记的第一条就是 dict 的 key 必须是 不可变对象,因为 dict 根据 key 来计算 value 的存储位置，

在 Python 中，字符串、整数等都是不可变的，因此，可以放心地作为 key。而 list 是可变的，就不能作为 key.











## 变量

a = 'ABC' 时，Python 解释器干了两件事情：

1. 在内存中创建了一个 'ABC' 的字符串；
2. 在内存中创建了一个名为 a 的变量，并把它指向 'ABC' 。

也可以把一个变量 a 赋值给另一个变量 b ，这个操作实际上是把变量 b指向变量 a 所指向的数据，

```python
In [62]: a=10

In [63]: b=a

In [64]: a=a+2

In [65]: a
Out[65]: 12

In [66]: b  #a变量改变了，但是b的值还没有变。
Out[66]: 10
    

```

运算符:

```
+ - * /
// 底板除，取整数
** 乘机，也就是幂运算
%	取模运算

```

## 字符编码



ascii编码:

因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。由于计算机是美国人发明的，因此，最早只有 127 个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII 编码。



Unicode：

全世界有上百种语言，日本把日文编到 Shift_JIS里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码因此，Unicode 应运而生。Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了，把不时数字的类型。映射成数字，这个映射表就是编码表。Unicode 标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要 4 个字节） ASCII 编码和 Unicode 编码的区别：ASCII 编码是 1 个字节，而 Unicode 编码通常是 2 个字节。汉字 中 已经超出了ASCII编码的范围，用Unicode编码是十进制的 20013 ，二进制的 01001110 00101101 。



utf8登场:

如果统一成 Unicode 编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用 Unicode 编码比 ASCII
编码需要多一倍的存储空间，在存储和传输上就十分不划算。所以，本着节约的精神，又出现了把 Unicode 编码转化为“可变长编码”
的 UTF-8 编码。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。如果你要传输的文本包含大量英文字符，用 UTF-8 编码就能节省空间：



**重点**

在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。



用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件。



浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器。



所以你看到很多网页的源码上会有类似 <meta charset="UTF-8" /> 的信息，表示该网页正是用的 UTF-8 编码。



搞清楚了令人头疼的字符编码问题后，我们再来研究 Python 的字符串。在最新的 Python 3 版本中，字符串是以 Unicode 编码的，也就是说，Python 的字符串支持多语言



对于单个字符的编码，Python 提供了 ord() 函数获取字符的整数表示，chr() 函数把编码转换为对应的字符：

ord 函数和 ， char函数

```python
In [67]: ord('A')  #查看字符串的编码
Out[67]: 65

In [68]: ord('B')
Out[68]: 66

In [69]: ord('a')
Out[69]: 97

In [70]: ord('b')
Out[70]: 98

In [72]: chr(65)  #根据编码取出字符串
Out[72]: 'A'

In [73]: chr(66)
Out[73]: 'B'

In [74]: chr(66)

#如果知道字符的整数编码，还可以用十六进制这么写 str ：
>>> '\u4e2d\u6587'  #python3 显示中文汉字，python2不会显示 中文这两个字是原封不动输出
'中文'

#以 Unicode 表示的 str 通过 encode() 方法可以编码为指定的 bytes ，例如：
>>> 'ABC'.encode('ascii')
b'ABC'
>>> '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
>>> '中文'.encode('ascii')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
>>>

'''
纯英文的 str 可以用 ASCII 编码为 bytes ，内容是一样的，含有中文的 str
可以用 UTF-8 编码为 bytes 。含有中文的 str 无法用 ASCII 编码，因为中
文编码的范围超过了 ASCII 编码的范围，Python 会报错
在 bytes 中，无法显示为 ASCII 字符的字节，用 \x## 显示。

反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是
bytes 。要把 bytes 变为 str ，就需要用 decode() 方法：
'''

>>> b'ABC'.decode('ascii')
'ABC'
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'

要计算 str 包含多少个字符，可以用 len() 函数：
>>> len('aaa')
3

len() 函数计算的是 str 的字符数，如果换成 bytes ， len() 函数就计算字
节数：
>>> len(b'ABC')
3
可见，1 个中文字符经过 UTF-8 编码后通常会占用 3 个字节，而 1 个英文字符只占用 1 个字节

在操作字符串时，我们经常遇到 str 和 bytes 的互相转换。为了避免乱码问题，应当始终坚持使用 UTF-8 编码对 str 和 bytes 进行转换。


#!/usr/bin/env python3
# -*- coding: utf-8 -*-

第一行注释是为了告诉 Linux/OS X 系统，这是一个 Python 可执行程序，
第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码.
申明了 UTF-8 编码并不意味着你的 .py 文件就是 UTF-8 编码的，必须并且要确保文本编辑器正在使用 UTF-8 without BOM 编码
也就是你编辑器使用的编码要和你声明的编码一致，要不也会报错。


```

字符串替换

就是输出时候，不知道具体输出内容，先用%d代替占位，之后根据具体变量来传入，不同代码表示传入不同的参数类型。



%d 整数
%f 浮点数
%s 字符串
%x 十六进制整数



```python
>>> 'growth rate: %d ' %7
'growth rate: 7 '
```

tuple
另一种有序列表叫元组：tuple。tuple 和 list 非常类似，但是 tuple 一旦
初始化就不能修改，比如同样是列出同学的名字：classmates = ('Michael', 'Bob', 'Tracy')
现在，classmates 这个 tuple 不能变了，它也没有 append()，insert()这样
的方法。其他获取元素的方法和 list 是一样的，你可以正常地使用。



tuple 的陷阱：当你定义一个 tuple 时，在定义的时候，tuple 的元素就必
须被确定下来，比如：t = (1, 2)

空的元组t=()

但是，要定义一个只有 1 个元素的 tuple，

如果你这么定义t = (1)定义的不是 tuple，是 1 这个数！这是因为括号 () 既可以表示 tuple，又
可以表示数学公式中的小括号，这就产生了歧义，因此，Python 规定，只有 1 个元素的 tuple 定义时必须加一个逗号 , ，来消除歧义：

```python
t = (1,)
t
(1,)
```

最后来看一个“可变的”tuple：

```python
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])

这里可变的是里面的列表
```

数据类型练习：

```python
#中括号是列表，这个是列表嵌套，直接解析就可以了
L = [
['Apple', 'Google', 'Microsoft'],
['Java', 'Python', 'Ruby', 'PHP'],
['Adam', 'Bart', 'Lisa']
]

In [36]: print(L[0])
['Apple', 'Google', 'Microsoft']

In [37]: print(L[1])
['Java', 'Python', 'Ruby', 'PHP']

In [38]: print(L[2])
['Adam', 'Bart', 'Lisa']

# 打印 Apple:
print(L[0][0])
# 打印 Python:
print(L[1][1])
# 打印 Lisa:
print(L[2][-1])
```

## IF 判断

```python
age = 20
if age >= 18:
	print('your age is', age)
	print('adult')
#根据 Python 的缩进规则，如果 if 语句判断是 True ，就把缩进的两行 print语句执行了，否则，什么也不做。

也可以给 if 添加一个 else 语句，意思是，如果 if 判断是 False ，不要执行 if 的内容，去把 else 执行了：

age = 3
if age >= 18:
	print('your age is', age)
	print('adult')
else:  #注意不要少写了冒号 : 
	print('your age is', age)
	print('teenager')
    
也可以用 elif 做更细致的判断
age = 3
if age >= 18:
	print('adult')
elif age >= 6:
	print('teenager')
else:
	print('kid')
    
#elif 是 else if 的缩写，完全可以有多个 elif ，所以 if 语句的完整形式就是：

if <条件判断 1>:
	<执行 1>
elif <条件判断 2>:
	<执行 2>
elif <条件判断 3>:
	<执行 3>
else:
	<执行 4>
    
#if 语句执行有个特点，它是从上往下判断，如果在某个判断上是 True ，把该判断对应的语句执行后，就忽略掉剩下的 elif 和 else ，
#所以，请测试并解释为什么下面的程序打印的是 teenager ：

age = 20
if age >= 6:
	print('teenager')
elif age >= 18:
	print('adult')
else:
	print('kid')
if 判断条件还可以简写，比如写：
if x:
	print('True')
    
#如果是if而不是elif那么只要是满足if就会执行
age=input("请输入年龄：")
age=int(age)
if age > 2000:
    print("您是00后！")
if age > 2100:
    print("您是10后！")
elif age > 2100:
    print("您输入的是"+str(age))
    
#执行结果： python version: 3.7.9
==========start time 2021/10/12 14:14 ======
请输入年龄：2101
您是00后！
您是10后！  #两个满足调解的if都执行了。


```

## 循环



要计算 1+2+3+...+10000，直接写表达式就不可能了为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。
Python 的循环有两种，一种是 for...in 循环，

```python
names = ['Michael', 'Bob', 'Tracy']
for name in names:
	print(name)
```

 range() 函数 生成序列

```python
In [3]: list(range(1,5))
Out[3]: [1, 2, 3, 4]
    
# 打印数字 0 - 9
for x in range(10):
    print(x)
```

第二种循环是 while 循环，只要条件满足，就不断循环，条件不满足时
退出循环。比如我们要计算 100 以内所有奇数之和，可以用 while 循环
实现：

```python
print("=====while函数联系======")
sum = 0
n = 99
while n > 0:
	sum = sum + n
	n = n - 2
print(sum)
```

### 迭代

如果给定一个 list 或 tuple，我们可以通过 for 循环来遍历这个 list 或tuple，这种遍历我们称为迭代（Iteration）。

在 Python 中，迭代是通过 for ... in 来完成的

ist 这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如 dict 就可以迭代
```python
In [21]: d = {'a': 1, 'b': 2, 'c': 3}

In [22]: for i in d:
    ...:     print(i)
    ...:
a
b
c
```

那么，如何判断一个对象是可迭代对象呢？方法是通过 collections 模块的 Iterable 类型判断：



```python
>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str 是否可迭代
True
>>> isinstance([1,2,3], Iterable) # list 是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False
```

python 要打印迭代的下标和指，需要使用下标循环来进行。Python 内置的 enumerate 函数可以把一个 list 变成索引-元素对，这样就
可以在 for 循环中同时迭代索引和元素本身：

```python
In [28]: for i, value in enumerate(['A', 'B', 'C']):
    ...:     print(i, value)
    ...:
0 A
1 B
2 C
```

for循环可以循环2个变量。例如：

```python
In [29]: for x, y in [(1, 1), (2, 4), (3, 9)]:
    ...:         print(x, y)
    ...:
1 1
2 4
3 9
```

同时迭代 key 和 value：

```python
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> for k, v in d.items():
... print(k, '=', v)
...
y = B
x = A
z = C

列表生成式也可以使用两个变量来生成 list：
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']

把一个 list 中所有的字符串变成小写：
>>> L = ['Hello', 'World', 'IBM', 'Apple']
>>> [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
```





## 函数

函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：



```python
>>> a = abs # 变量 a 指向 abs 函数
>>> a(-1) # 所以也可以通过 a 调用 abs 函数
1
```

定义函数
在 Python 中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号 : ，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。

```python
In [3]: def ff(x):
   ...:     if x>=0:
   ...:         return x
   ...:     else:
   ...:         return -x
   ...:

In [4]: ff(-1)
Out[4]: 1

In [5]: ff(1)
Out[5]: 1
    
In [6]: def f2(x,y):
   ...:     if x>=0 and y>=0:
   ...:         return x+y
   ...:     else:
   ...:         print("数据不是正数！")
   ...:
    
def nop():
	pass  #pass 占位符，没有这个pass那么函数语句检查会报错。


数据类型检查可以用内置函数 isinstance() 实现：



```

请注意，函数体内部的语句在执行时，一旦执行到 return 时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑



数据类型检查可以用内置函数 isinstance() 实现：



isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。

> isinstance() 与 type() 区别：
>
> - type() 不会认为子类是一种父类类型，不考虑继承关系。
> - isinstance() 会认为子类是一种父类类型，考虑继承关系。
>
> 如果要判断两个类型是否相同推荐使用 isinstance()。



```python
def my_abs(x):
if not isinstance(x, (int, float)):
	raise TypeError('bad operand type')
if x >= 0:
	return x
else:
	return -x
```

```python
#type() 与 isinstance()区别：
class A:
    pass
 
class B(A):
    pass
 
isinstance(A(), A)    # returns True
type(A()) == A        # returns True
isinstance(B(), A)    # returns True
type(B()) == A        # returns False
```

函数返回多个值的问题：

Python 的函数返回多值其实就是返回一个 tuple，但写起来更方便,按位置赋给对应的值



函数小结：

```bash
1.定义函数时，需要确定函数名和参数个数；
2.如果有必要，可以先对参数的数据类型做检查；
3.函数体内部可以用 return 随时返回函数结果；
4.函数执行完毕也没有 return 语句时，自动 return None 。
5.函数可以同时返回多个值，但其实就是一个 tuple。
```

### 函数的参数

Python 的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。



1. 位置参数，根据输入的位置匹配参数

2. 默认参数，没有输入指定的参数就会给参数一个默认值，便于函数调用，少传参，默认参数在后，否则 Python 的解释器会报错，

有多个默认参数时，调用的时候，既可以按顺序提供默认参数，也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，
需要把参数名写上。

```python
我们可以把年龄和城市设为默认参数：
def enroll(name, gender, age=6, city='Beijing'):
	print('name:', name)   # age 和city是默认参数
	print('gender:', gender)
	print('age:', age)
	print('city:', city)
```

定义函数变量时候的坑，就是定义一个可变的变量时候，每次都要进行初始化

Python 函数在定义的时候，默认参数 L 的值就被计算出来了，即 [] 列表，因为默认参数 L 也是一个变量，它指向对象 [] ，每次调用该函数，如果改变了 L 的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的 [] 了。

定义默认参数要牢记一点：**默认参数必须指向不变对象**

例如：

```python
def add_end(L=None):  
	if L is None:  #对L进行初始化
		L = []
	L.append('END')
	return L
```

为什么要设计 str 、 None 这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。



3. 可变参数 星号开头

```python
def calc(*numbers): #定义一个可变参数，接受到的参数都放到numbers里面之后进行循环取出来。
	sum = 0
	for n in numbers:
		sum = sum + n * n
	return sum
```

在函数内部，参数 numbers 接收到的是一个 tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括 0 个
这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple
前面加一个 * 号，把 list 或 tuple 的元素变成可变参数传进去

```python
>>> nums = [1, 2, 3]
>>> calc(*nums)  #这里面的calc函数就是上面定义的函数，这里只是传参时候省略了。直接使用变量来传参。
14

```

4. 关键字参数

关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict

关键字参数使用2个星号。

```python
def person(name, age, **kw):  #定义关键字参数kw
	print('name:', name, 'age:', age, 'other:', kw)
    
#函数 person 除了必选参数 name 和 age 外，还接受关键字参数 kw 。

#在调用该函数时，可以只传入必选参数：
>>> person('Michael', 30)
name: Michael age: 30 other: {} #这里没有关键字参数传入，就打印出空字典

#也可以传入关键字参数
也可以传入任意个数的关键字参数：
>>> person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
```

关键字参数有什么用？它可以扩展函数的功能。比如，在 person 函数里，我们保证能接收到 name 和 age 这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到并使用。



5. 命名关键字参数

   和关键字参数 **kw 不同，命名关键字参数需要一个特殊分隔符 * ， * 后面的参数被视为命名关键字参数

   ```python
   #如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收 city 和 job 作为关键字参数。这种方式定义的函数如下：
   def person(name, age, *, city, job):
   		print(name, age, city, job)
           
   #调用方式如下：
   >>> person('Jack', 24, city='Beijing', job='Engineer')
   Jack 24 Beijing Engineer
   
   #命名关键字参数可以有缺省值，从而简化调用：
   def person(name, age, *, city='Beijing', job):
   	print(name, age, city, job)
   
   #由于命名关键字参数 city 具有默认值，调用时，可不传入 city 参数
   >>> person('Jack', 24, job='Engineer')
   			Jack 24 Beijing Engineer
   ```

   **使用命名关键字参数时，要特别注意， 星号 不是参数，而是特殊分隔符**

参数组合
在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这 5 种参数都可以组合使用，除了可变参数无法和命名关键字参数混合。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数/命名关键字参数和关键字参数。



参数小结：

默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！

要注意定义可变参数和关键字参数的语法：*args 是可变参数，args 接收的是一个 tuple；

**kw 是关键字参数，kw 接收的是一个 dict。

关键字参数既可以直接传入： func(a=1, b=2) ，又可以先组装 dict，再通
过** **kw 传入： func(**{'a': 1, 'b': 2}) 。

```python
使用 *args 和 **kw 是 Python 的习惯写法，当然也可以用其他参数名，但最好使用习惯用法
```

命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。

```python
定义命名的关键字参数不要忘了写分隔符 * ，否则定义的将是位置参数
```

## 递归函数

递归就是自己引用本身。

 fact(n) 可以表示为 n x fact(n-1) ，只有 n=1 时需要特殊处理。
于是， fact(n) 用递归的方式写出来就是：

```python
def fact(n):
	if n==1:
		return 1
	return n * fact(n - 1)


```

递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。



使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试 fact(1000) ：

解决递归调用栈溢出的方法是通过 尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。



## 字符串切片

一次取出多个元素。例如列表

```python
In [7]: l=['a','b','c','d']

In [8]: l[1-2]
Out[8]: 'd'

In [9]: l[1-4]
Out[9]: 'b'

In [10]: l[1:4]
Out[10]: ['b', 'c', 'd']

In [11]: l[:1]
Out[11]: ['a']

In [12]: l[:3]  #起始位置是0可以省略
Out[12]: ['a', 'b', 'c']
    
In [13]: l[-1] #从右开始取，也就是从最后位开始取。
Out[13]: 'd'

L = list(range(100))

In [18]: L[-10:] #取出最后10位元素
Out[18]: [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
    
#所有数，每 5 个取一个：
>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85,
90, 95]

#前 10 个数，每两个取一个：
>>> L[:10:2]
[0, 2, 4, 6, 8]

#甚至什么都不写，只写 [:] 就可以原样复制一个 list：
>>> L[:]
[0, 1, 2, 3, ..., 99]

tuple 也是一种 list，唯一区别是 tuple 不可变。因此，tuple 也可以用切片操作，只是操作的结果仍是 tuple：
>>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)

字符串 'xxx' 也可以看成是一种 list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：
>>> 'ABCDEFG'[:3]
'ABC'
>>> 'ABCDEFG'[::2]
'ACEG'



```



## 列表生成式



要生成 list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 可以用 list(range(1,11)) ：

但如果要生成 [1x1, 2x2, 3x3, ..., 10x10] 怎么做？方法一是循环：

```python
>>> L = []
>>> for x in range(1, 11):
... L.append(x * x)
...
>>> L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

循环太繁琐
列表生成式则可以用一行语句代替循环生成上面的list

[x * x for x in range(1, 11)]

写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环
for 循环后面还可以加上 if 判断，这样我们就可以筛选出仅偶数的平方：

>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]

还可以使用两层循环，可以生成全排列：
>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
三层和三层以上的循环就很少用到了。

运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：
>>> import os # 导入 os 模块，模块的概念后面讲到
>>> [d for d in os.listdir('.')] # os.listdir 可以列出文件和目录
 
```



python列出当前目录所有文件和目录名

```python
In [5]:  [d for d in os.listdir('.')]  #括号里面的点表示当前目录
Out[5]: ['3306_data', '3307_data', 'tmp', '3308_data', 'config_bak']
```



## 生成器



就是一次不全部产生出来，而是一边使用一边创建出来，这种方式就是生成器。



通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含 100 万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的 list

在 Python 中，这种一边循环一边计算的机制，称为生成器：generator。



创建生成器：

方法有很多。最简单的方法是：

```python
第一种方法很简单，只要把一个列表生成式的 [] 改成 () ，就创建了一个 generator生成器：
>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10))
>>> g
```




# 学习进度：

进度 ：113 页



















